---
layout: post
title: "PHP正则表达式，看这一篇就够了"
subtitle: "Hello PHP, Hello 正则"
date: 2021-05-19
author: "Hux"
header-img: "img/post-bg-2015.jpg"
tags: 
    - php
---

能大家之前听说过正则表达式，大概的印象是很难学、很复杂，有种深不可测的感觉。其实正则表达式没有那么神秘，它是描述字符排列模式的一种自定义语法规则。许多语言，比如 PERL、PHP、Python、JavaScript 等都支持使用正则表达式。

 

## 什么是正则表达式

正则表达式也称为模式表达式，自身具有一套非常完整的、可以编写模式的语法体系，提供了一种灵活且直观的字符串处理方法。正则表达式通过构建具有特定规则的模式，与输入的字符串信息比较，在特定的函数中使用从而实现字符串的匹配、查找、替换及分割等操作。

举个我们在日常生活中的例子，如果想搜索电脑某个目录下的所有 txt 格式的文件，就可以在该目录下输入`*.txt`，然后按回车键，就可以列出目录下的所有 txt 格式的文件了。这里使用到的`*.txt`就可以理解为一个简单的正则表达式。

下面使用正则表达式的语法构建了两个例子，如下所示：

````
/http(s)?:\/\/[\w.]+[\w\/]*[\w.]*\??[\w=&\+\%]*/is   // 匹配网址 URL 的正则表达式
/^\w{3,}@([a-z]{2,7}|[0-9]{3})\.(com|cn)$/          // 匹配邮箱地址的正则表达式
````

不要被上例中看似乱码的字符串给吓退，它们就是按照正则表达式的语法规则构建的，是一种由普通字符和具有特殊功能的字符组成的字符串。而且要将这些字符串放在特定的正则表达式函数中使用才有效果。

## 正则表达式的用途

正则表达式描述的是一种字符串匹配模式，可以用来检查一个字符串中是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等等。例如，当用户提交一个表单后，要判断输入的电话号码、E-mail 地址等是否有效，用普通的基于字面的字符验证显然是不够的。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为“元字符”）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。正则表达式的模式可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

使用正则表达式的目的就是可以通过简单的办法来实现强大的功能。为了简单、有效而又不失强大，造成了正则表达式规则的复杂，构建正确、有效的正则表达式更是难度较大，所以需要付出一些努力才行。入门之后通过一定的参考和大量实践，在开发实践中使用正则表达式还是比较有效且有趣的。

## 正则表达式中的常用术语

在学习正则表达式之前，先来了解一下正则表达式中几个容易混淆的术语，这对于学习正则表达式有很大的帮助。

#### 1) grep

最初是 ED 编辑器中的一条命令，用来显示文件中特定的内容。后来成为一个独立的工具 grep。

#### 2) egrep

grep 虽然不断地更新升级，但仍然无法跟上技术的脚步。为此，贝尔实验室写出了 egrep，意为“扩展的 grep"。这大大增强了正则表达式的能力。

#### 3) POSIX（Portable Operating System Interface of UNIX）

可移植操作系统接口。在 grep 发展的同时，其他一些开发人员也根据自己的喜好开发出了具有独特风格的版本。但问题也随之而来，有的程序支持某个元字符，而有的程序则不支持。因此，就有了POSIX。POSIX 是一系列标准，确保了操作系统之间的移植性。不过 POSIX 和 SQL 一样，没有成为最终的标准而只能作为一个参考。

#### 4) Perl（Practical Extraction and Reporting Language）

实际抽取与汇报语言。1987 年，Larry Wall 发布了 Perl。在随后的 7 年时间里，从 Perl1 到现在的 Perl5，最终成为了 POSIX 之后的另一个标准。

#### 5) PCRE

Perl 的成功，让其他的开发人员在某种程度上要兼容"Perl"，包括 C/C++、Java、Python 等都有自己的正则表达式。1997 年，Philip Hazel 开发了 PCRE 库，这是兼容 Perl 正则表达式的一套正则引擎，其他开发人员可以将 PCRE 整合到自己的语言中，为用户提供丰富的正则功能。许多软件都使用 PCRE，PHP 正是其中的一员。

## 正则表达式语法规则

在使用正则表达式之前我们一定要先来学习正则表达式的语法。正则表达式的构成元素中一般包括普通字符、元字符、限定符、定位点、非打印字符和指定替换项等。

#### 1) 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符，包括所有大小写字母、数字、标点符号和一些符号。最简单的正则表达式是用于搜索字符串相比较的单个普通字符。例如，单字符正则表达式`/A/`会始终匹配字母 A。

也可以将多个单字符组合起来形成较长的表达式，例如，正则表达式`/the/`会匹配搜索字符串中的 the、there、other 和 over the lazy dog 等。无须使用任何串联运算符，只需连续输入字符即可。

#### 2) 元字符

除普通字符之外，正则表达式还可以包含“元字符”。元字符可分为单字符元字符和多字符元字符。例如，元字符`\d`，它与数字字符相匹配。

下表中列出了所有的单字符元字符。



| 元字符 | 行为                                                         | 示例                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| *      | 零次或多次匹配前面的字符或子表达式，等效于{0,}               | zo* 与 “z”和“zoo”匹配                                        |
| +      | 一次或多次匹配前面的字符或子表达式，等效于{1,}               | zo+ 与 “zo”和“zoo”匹配，但与“z”不匹配                        |
| ?      | 零次或一次匹配前面的字符或子表达式，等效于{0,1} 当 ? 紧随任何其他限定符（*、+、?、{n}、{n,} 或 {n,m}）之后时，匹配模式是非贪婪的。非贪婪模式匹配搜索到的、尽可能少的字符串，而默认的贪婪模式匹配搜索到的、尽可能多的字符串 | zo? 与“z”和“zo”匹配，但与“zoo”不匹配 o+? 只与“oooo”中的单个“o”匹配，而 o+ 与所有“o”匹配 do(es)? 与“do”或“does”中的“do”匹配 |
| ^      | 匹配搜索字符串开始的位置。如果标志中包括 m（多行搜索）字符，^ 还将匹配 \n 或 \r 后面的位置。如果将 ^ 用作括号表达式中的第一个字符，就会对字符集取反 | ^\d{3} 与搜索字符串开始处的 3 个字符匹配 [^abc] 与除 a、b、c 以外的任何字符匹配 |
| $      | 匹配搜索字符串结束的位置。如果标志中包括 m（多行搜索）字符，^ 还将匹配 \n 或 \r 前面的位置。 | \d{3}$ 与搜索字符串结尾处的 3 个数字匹配                     |
| .      | 匹配除换行符 \n 之外的任何单个字符。若要匹配包括 \n 在内的任意字符，请使用诸如 [\s\S] 之类的模式 | a.c 与 “abc”“a1c”和“a-c”匹配                                 |
| []     | 标记括号表达式的开始和结尾                                   | [1-4] 与“1”、“2”、“3”或“4”匹配 [^aAeEiIoOuU] 与任何非元音字符匹配 |
| {}     | 标记限定符表达式的开始和结尾                                 | a{2,3} 与“aa”和“aaa”匹配                                     |
| ()     | 标记子表达式的开始和结尾，可以保存子表达式，以备将来之用     | A(\d) 与“A0”至“A9”匹配。保存该数字以备将来之用               |
| \|     | 指示两个或多个项之间进行选择                                 | z\|food 与“z”或“food”匹配 (z\|f)ood 与 “zood”或“food”匹配    |
| /      | 表示 JavaScript 中的文本正则表达式模式的开始和结尾。在第二个 “/”后添加单字符标志可以指定搜索行为 | /abc/gi 是与 “abc”匹配的 JavaScript 文本正则表达式。g（全局）标志指定查找模式的所有匹配项，i（忽略大小写）标志使搜索不区分大小写 |
| \      | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符       | \n 与换行符匹配。\( 与 “(”匹配。\\ 与 “\”匹配                |


这些特殊字符在括号表达式内出现时就会失去它们的意义，变成普通字符。若要匹配这些特殊字符，必须首先转义字符，即在字符前面加反斜杠`\`。例如，若要搜索`+`文本字符，则可使用表达式`\+`。

除了以上单字符元字符外，还有一些多字符元字符，如下表所示。



| 元字符   | 行为                                                         | 示例                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| \b       | 与一个字边界匹配。即字与空格间的位置                         | er\b 与 “never”中的“er”匹配，但与“verb”中的“er”不匹配        |
| \B       | 非边界字匹配                                                 | er\B 与“verb”中的“er”匹配，但与“never”中的“er”不匹配         |
| \d       | 数字字符匹配，等效于[0-9]                                    | 在搜索字符串“12 345”中，\d{2} 与“12”和“34”匹配。\d 与“1”，“2”、“3”、“4”和“5”匹配 |
| \D       | 非数字字符匹配，等效于[^0-9]                                 | /D+ 与“abc123 def”中的“abc”和“def”匹配                       |
| \w       | 与 A-Z、a-z、0-9 和下划线中的任意任意字符匹配，等效于[A-Za-z0-9] | 在搜索字符串“The quick brown fox...”中，\w+ 与“The”、“quick”、“brown”和“fox”匹配 |
| \W       | 与除 A-Z、a-z、0-9 和下划线以外的任意字符匹配，等效于[^A-Za-z0-9] | 在搜索字符串“The quick brown fox...”中，\W+ 与“...”和所有空格匹配 |
| [xyz]    | 字符集，与任何一个指定字符匹配                               | [abc] 和 “plain”中的“a”匹配                                  |
| [^xyz]   | 反向字符集，与未指定的任何字符匹配                           | [^abc] 与“plain”中的“p”、“1”、“i”和“n”匹配                   |
| [a-z]    | 字符范围，匹配指定范围内的任何字符                           | [a-z] 与“a”到“z”范围内的任何小写字母字符匹配                 |
| [^a-z]   | 反向字符范围，与不在指定范围内的任何字符匹配                 | [^a-z] 与不在范围“a”到“z”内的任何字符匹配                    |
| {n}      | 正好匹配 n 次，n 是非负整数                                  | o{2} 与“Bob”中的“o”不匹配，但与“fooood”中的两个“o”匹配       |
| {n,}     | 至少匹配 n 次，n 是非负整数 * 与 {0,} 相等 + 与 {1,} 相等    | o{2} 与“Bob”中的“o”不匹配，但与“fooood”中的所有“o”匹配       |
| {n,m}    | 匹配至少 n 次，至多 m 次。n 和 m 是非负整数，其中 n<= m，逗号和数字之间不能有空格 ? 与 {0,1} 相等 | 在搜索字符串“1234567”中，\d{1,3} 与“123”、“456”和“7”匹配     |
| (模式)   | 与模式匹配并保存匹配项。可以从由 JavaScript 中的 exec Method 返回的数组元素中检索保存的匹配项。若要匹配括号字符()，请使用“\(”或者“\)” | (Chapter\|Section) [1-9] 与 “Chapter 5”匹配，保存“Chapter”以备将来之用 |
| (?:模式) | 与模式匹配，但不保存匹配项，即不会存储匹配项以备将来之用。这对于用“or”字符(\|)组合模式部件的情况很有用 | industry(?:y\|ies) 与 industry\|industries 相等              |
| (?=模式) | 正预测先行。找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。不会保存匹配项以备将来之用 | ^(?=_.*\d.{4,8}$ 对密码应用一下限制： 其长度必须介于 4 到 8 字符之间，并且必须至少包含一个数字，在该模式中，*\d 查找后跟有数字的任意多个字符。对于搜索字符串“abc3qr”，与“abc3”匹配。 从该匹配项之前，（而不是之后）开始，{4,8} 与包含 4~8 个字符的字符串匹配，与“abc3qr”匹配。 ^ 和 $ 指定搜索字符串的开始和结束位置，将在搜索字符串包含匹配字符之外的任何字符时阻止匹配 |
| (?!模式) | 负预测先行。匹配与模式不匹配的搜索字符串。找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。不会保存匹配项以备将来之用 | \b(?!th)/w+\b 与不以“th”开头的单词匹配在该模式中，\b 与一个字边界匹配。对于搜索字符串“quick”，与第一个空格匹配。(?!th) 与非“th”字符串匹配与“qu”匹配，从该匹配项开始，!w+ 与一个字匹配，即与“quick”匹配 |
| \cx      | 匹配 x 指示的控制字符。x 的值必须在 A-Z 或 a-z 范围内。如果不是这样，就假定 c 是文本“c”字符本身 | \cM 与 Ctrl+M 或一个回车符匹配                               |
| \xn      | 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。允许在正则表达式中使用 ASCII 代码 | \x41 与“A”匹配、\x41 等效于后跟有“1”的“\x04”（因为 n 必须正好是两位数） |
| \num     | 匹配 num，此处的 num 是一个正整数。这是对以保存的匹配项的引用 | (.)\1 与两个连续的相同字符匹配                               |
| \n       | 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用；否则，如果 n 是八进制数（0-7），那么 n 是八进制转义码 | (\d)\1 与两个连续的相同数字匹配                              |
| \nm      | 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获子表达式，则 n 是反向引用，后面跟有文本 m。如果上述情况都不存在，当 n 和 m 是八进制数字（0-7）时，\nm 匹配八进制转义码 nm | \11 与制表符匹配                                             |
| \nml     | 当 n 是八进制数字（0-3）、m 和 1 是八进制数字（0-7）时，匹配八进制转义码 nml | \011 与制表符匹配                                            |
| \un      | 匹配 n，其中 n 是以 4 位十进制数字表示的 Unicode 字符        | \u00A9 与版权符号（©️）匹配                                   |

#### 3) 非打印字符

非打印字符是由普通字符与转义字符组成，用来在正则表达式中匹配特定行为的字符，如换行、换页、空白符等。下表列出了非打印字符。



| 字符 | 匹配                                   | 等效于        |
| ---- | -------------------------------------- | ------------- |
| \f   | 换页符                                 | \x0c 和 \cL   |
| \n   | 换行符                                 | \x0a 和 \cJ   |
| \r   | 回车符                                 | \x0d 和 \cM   |
| \s   | 任何空白字符，包括空格、制表符和换页符 | [\f\b\r\t\v]  |
| \S   | 任何非空白字符                         | [^\f\b\r\t\v] |
| \t   | Tab 字符                               | \x09 和 \cI   |
| \v   | 垂直制表符                             | \x0b 和 \cK   |

#### 4) 优先级顺序

在使用正则表达式时，需要注意匹配的顺序。通常相同优先级是从左到右进行运算的，不同优先级的运算先高后低。各种操作符的匹配顺序优先级从高到低，如下表所示。



| 顺序 | 元字符                  | 描述         |
| ---- | ----------------------- | ------------ |
| 1    | \                       | 转义符       |
| 2    | ( )、(?:)、(?=)、[ ]    | 括号和中括号 |
| 3    | *、+、{n}、{n，}、{n,m} | 限定符       |
| 4    | ^、$、\ 任何元字符      | 定位点和序列 |
| 5    | \|                      | 替换         |


另外，字符具有高于替换运算符的优先级，例如，允许 "m|food" 匹配 "m" 或 "food"。

## 替换

正则表达式中的替换允许对两个或多个替换选项之间的选择进行分组。实际上可以在模式中指定两种匹配模式的或关系。可以使用管道`|`字符指定两个或多个替换选项之间的选择，称之为“替换”。匹配管道字符任一侧最大的表达式。

例如：

/Chapter|Section [1-9][0-9]{0,1}/

该正则表达式匹配的是字符串“Chapter”或者字符串“Section”后跟一个或两个数字。

如果搜索字符串是“Section 22”，那么该表达式匹配“Section 22”。但是，如果搜索字符串是“Chapter 22”，那么表达式匹配单词“Chapter”，而不是匹配“Chapter 22”。

为了解决这种形式的表达式可能带来的误导，可以使用括号来限制替换的范围，即确保它只应用于两个单词“Chapter”和“Section”。可以通过添加括号来使正则表达式匹配“Chapter 1”或“Section 3”。将以上表达式改成如下形式：

/(Chapter|Section) [1-9][0-9]{0,1}/

修改后，如果搜索字符串是“Section 22”，那么该表达式匹配“Section 22”。如果搜索字符串是“Chapter 22”，那么表达式匹配单词也会是“Chapter 22”。

## 子表达式

正则表达式中放置括号可创建子表达式，子表达式允许匹配搜索文本中的模式并将匹配项分成多个单独的子匹配项，程序可检索生成的子匹配项。

例如匹配邮箱账号的正则表达式：

/(\w+)@(\w+)\.(\w+)/

该正则表达式包含 3 个子表达式，3 个子表达式分别进行匹配并保留匹配结果，与其他表达式匹配结果作为一个整体显示出来。

下面的示例将通用资源指示符（URI）分解为其组件：

/(\w+):\/\/([^\/:]+)(:\d*)?([^# ]*)/

第一个括号子表达式保存 Web 地址的协议部分，匹配在冒号和两个正斜杠前面的任何单词。

第二个括号子表达式保存地址的域地址部分，匹配不包括左斜线`/`或冒号`：`字符的任何字符序列。

第三个括号子表达式保存网站端口号（如果指定了的话），匹配冒号后面的零个或多个数字。

第四个括号子表达式保存 Web 地址指定的路径和/或页信息，匹配零个或多个数字字符`#`或空白字符之外的字符。

如果我们使用这个正则表达式匹配字符串“http://msdn.microsoft.com:80/scripting/default.htm”，那么 3 个子表达式的匹配结果分别为 http、msdn.microsoft.com:80、/scripting/default.htm。

## 反向引用

反向引用用于查找重复字符组。此外，可使用反向引用来重新排列输入字符串中各个元素的顺序和位置，以重新设置输入字符串的格式。

可以从正则表达式和替换字符串中引用子表达式。每个子表达式都由一个编号来标识，并称作反向引用。

在正则表达式中，每个保存的子匹配项按照它们从左到右出现的顺序存储。用于存储子匹配项的缓冲区编号从 1 开始，最多可存储 99 个子表达式。在正则表达式中，可以使用 \n 来访问每个缓冲区，其中 n 标识特定缓冲区的一位或两位十进制数字。

反向引用的一个应用是，提供查找文本中两个相同单词的匹配项的能力。以下面的句子为例：

Is is the cost of of gasoline going up up?

该句子包含多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，就会很有用。

下面的正则表达式使用单个子表达式来实现这一点：

/\b([a-z]+) \1\b/

在此情况下，子表达式是括在括号中的所有内容。该子表达式包括由 [a-z]+ 指定的一个或多个字母字符。正则表达式的第二部分是对以前保存的子匹配项的引用，即单词的第二个匹配项正好由括号表达式匹配。\1 用于指定第一个子匹配项。\b 单词边界元字符确保只检测单独的单词。否则，诸如“is issued”或“this is”之类的词组将不能正确地被此表达式识别。所以，使用表达式 /\b([a-z]+)\1\b/ 匹配字符串“Is is the cost of of gasoline going up up？”得到的结果为 is、of、up。

## 在 PHP 中使用正则表达式

PHP 有两套函数库支持的正则表达式处理操作：

- 一套是由 PCRE（Perl Compatible Regular Expression）库提供、与 Perl 语言兼容的正则表达式函数，以`preg_`为函数的前缀名称；
- 另一套是 POSIX（Portable Operating System Interface）扩展语法正则表达式函数，以`ereg_`为函数的前缀。


两套函数库的功能相似，但是 PCRE 的执行效率高于 POSIX，所以我们只介绍 PCRE 函数库。